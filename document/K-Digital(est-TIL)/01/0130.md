# 반복문

## For문

for ( 초기화;조건식;증감식 ){ 실행문 }

- 특정 조건이 참일 때 코드 블록을 반복해서 실행.
- false면 흐름 종료.

### 사용시 주의사항

- 초기화;조건식;증감식 잘못 설정시 무한루프가 실행.
- 최대한 반복 변수의 값을 업데이트.

## for each 문

for(요소의_데이터_타입 요소_변수 : 반복_대상){

// 요소를 사용한 작업 수행

}

- 주로 배열과 컬렉션(리스트, 맵 등)을 순회할 때 사용.
- 요소를 읽기만 가능하며, 요소를 수정할 수 없음.
- 반복 대상은 배열 또는 Iterable 인터페이스를 구현한 컬렉션 객체여야함.
    - Iterable이란, 순회할 수 있는 방법을 제공하는 인터페이스를 말함.
    - **`ArrayList`**, **`LinkedList`**, **`HashSet`**, **`TreeSet`** 등의 클래스는 모두 Iterable을 구현.
- 배열이나 컬렉션을 순회하거나 요소를 읽을 때 특히 유용.

## 이중 for 문

```java
for ( 초기화;조건식;증감식 ){
		// 반복문 코드
		for ( 초기화;조건식;증감식 ){
				//반복문 코드
		}
}
```

## continue;

- 현재 실행 중인 반복문의 이후 코드를 건너뛰고 다음 반복을 시작.

```java
for (int i = 1; i <= 5; i++) {
if (i == 3) {
continue; // i가 3일 때, 이후 코드를 실행하지 않고 다음 반복으로 이동
}
System.out.println("현재 i: " + i);
}
```

- 특정 상황에서 반복을 스킵하고자 할 때 사용되는 유용한 제어문 중 하나.

## break;

- 조건에 따라 중단하고 루프를 벗어나는데 사용되는 제어문.
- 어떤 값을 찾았을 때 반복문을 종료하고자 할 때 사용 가능.

## while 문

- 주어진 조건이 **false** 가 될 때까지 반복적으로 코드를 실행.
- 종료 조건을 명확하게 설정하지 않으면 무한루프 실행.
- 반복 횟수를 미리 알 수 없을 때 유용.

## do-while 문

- 루프의 본문을 실행한 후에 조건을 검사.
- while문과의 차이점으로 최소 한 번은 루프 본문이 실행된다는 것.

# 객체지향언어

소프트웨어 개발 방법론 중 하나로, 현실 세계의 개념을 프로그램으로 모델링하고 조작하는 데 중점을 둠.

## 객체 지향 프로그래밍의 특징

1. **캡슐화** :
    - 캡슐화는 객체의 상태를 보호하고 외부에서 직접 접근하지 못하도록 하는 개념.
    - 접근제한자를 사용하여 클래스 내부의 데이터를 캡슐화할 수 있음.
2. **상속**:
    - 상속은 부모 클래스(슈퍼 클래스)의 특성을 자식 클래스(서브 클래스)가 상속받아 재사용하는 개념.
    - 상속을 통해 중복 코드를 제거하고 코드 재사용성을 높일 수 있음.
    - 예시:

        ```java
        class Animal {
            void eat() {
                System.out.println("먹는 중");
            }
        }
        
        class Dog extends Animal {
            void bark() {
                System.out.println("짖는 중");
            }
        }
        ```

3. **다형성**:
    - 다형성은 같은 메서드 이름을 사용하면서 서로 다른 동작을 할 수 있도록 하는 개념.
    - 오버로딩과 오버라이딩을 통해 구현.
4. **추상화**:
    - 추상화는 복잡한 현실 세계를 단순화하여 필요한 부분만 포착하는 개념.
    - 추상 클래스와 인터페이스를 사용하여 추상화를 구현할 수 있음.

## 클래스와 객체

- 클래스란 객체의 특징(속성, 기능)을 정해놓은 `제품 설계도`같은 것.
- 객체는 실제로 존재하는 **제품**.
- 때문에 객체를 생성할 때 클래스가 필요한 것.
- 클래스에는 객체의 특징을 표현해놓는데, ‘속성’과 ‘기능’을 정의해놓을 수 있는데,
- 여기서 말하는 속성은 ‘필드’에 정의, 기능은 ‘ 메서드’에 정의 할 수 있음.

클래스 이름을 지을 때 다음과 같은 식별자 작성 규칙이 필요.

| 작성 규칙 | 예시 |
| --- | --- |
| 하나 이상의 문자로 이루어져야 한다. | Car, SportsCar |
| 첫 번째 글자는 숫자가 올 수 없다. | 3Car (x) |
| $ _ 외의 특수문자는 사용할 수 없다. | $Car, _Car, @Car (x), #Car (x) |
| 자바 키워드는 사용할 수 없다. | int (x), for (x) |

```
🖊️ 클래스에 의해서 만들어진 객체를 ‘인스턴스’라고도 함.
```

# 클래스의 구성멤버

## 필드(멤버변수)

객체의 고유 데이터가 저장되는 곳으로 클래스 전역에서 사용될 수 있으며 객체가 소멸되지 않는 한 객체와 함께 존재하는 변수를 뜻함.

## 생성자

### 생성자란

new 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당.

```jsx
★ 생성자 규칙

- 클래스명과 메서드명이 같다.
- 리턴 타입을 정의하지 않는다(void도 사용하지 않는다)

물론 생성자 앞에 접근제어자로 public 혹은 private 모두 올 수 있습니다. 

생성자는 객체가 생성될 때 호출되는데 다음과 같이 new 키워드가 사용될 때 호출
new 클래스명(입력인수, ...)
```

## this

**this**는 현재 객체를 가리키는 참조 변수.

- **this**를 사용하여 클래스의 멤버 변수와 메서드를 참조 가능.
- 주로 멤버 변수와 메서드의 이름이 동일한 경우 현재 객체를 명확히 식별하기 위해 사용.
- 클래스 내에서 사용할 때, 현재 객체를 가리키는 데 주로 사용.
- 객체의 상태를 관리하고 현재 객체와 멤버 변수 간의 충돌을 방지하는 데 도움을 줌.

### **규칙 및 참고사항**:

1. **this 키워드**: **this**는 Java의 예약어로, 식별자나 변수 이름으로 사용할 수 없음.
2. **멤버 변수와 로컬 변수 구분**: 클래스 내에서 **this**를 사용하여 멤버 변수와 로컬 변수를 구분할 수 있음. 예를 들어, 메서드 내에서 매개변수로 전달된 변수와 멤버 변수의 이름이 같은 경우 **this**를 사용하여 멤버 변수를 참조가능.
3. **생성자에서의 this**: 생성자에서 다른 생성자를 호출할 때 사용 가능. 이것은 생성자 중복 정의시 유용.

```java
class Rectangle {
    int width;
    int height;

    // 매개변수가 없는 생성자
    public Rectangle() {
        this(0, 0); // 다른 생성자 호출
    }

    // 매개변수가 있는 생성자
    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }
}
```