## js 사용시 Tip!

### DOM 사용시

DOM 트리 전체를 검색하는 `document.querySelector(클래스)` 대신, 특정 부모 요소 내에서 원하는 클래스를 찾기 위해 `부모요소.querySelector(자식클래스)`를 사용하는 것이 성능에 더 좋음. 이 방법은 검색 범위를 좁혀 DOM 탐색의 영향을 줄이는 데 도움을 줌.

### 클래스를 추가하거나 제거할땐 toggle!

클래스를 추가하거나 제거하는 작업에는 `add`와 `remove` 메소드도 유용하지만, `toggle` 메소드를 사용하면 코드가 더 간결해지고 효율적으로 동작이 가능.

```jsx
ex)

// 클래스 추가
element.classList.add('클래스명');

// 클래스 제거
element.classList.remove('클래스명');

// 클래스 토글
element.classList.toggle('클래스명');
```

# Java

## 자바의 특징

### 객체 지향 언어

- 부품에 해당하는 “객체”들을 만든 후 그 부품들을 조립하고 부품들끼리 연결하여 전체 프로그램을 완성하는 기법을 객체지향 프로그래밍(OOP)라고 함.

### 메모리를 자동으로 관리

- 개발자가 직접 메모리를 접근할 수 없게 설계되어있으므로 메모리는 자바가 직접 관리(Gabage Collector)하기 때문에 핵심 기능 코드 작성에 집중이 가능.

### 풍부한 라이브러리

- 자주쓰는 라이브러리를 풍부하게 제공하고 있어, 원하는 프로그램을 적은 노력으로 개발하기가 쉬움.

### 운영체제에 독립적

- JVM(Java Virtual Machine)의 기능을 통해 서로 다른 실행환경을 가진 시스템 간에 프로그램을 옮겨 실행할 수 있는 장점을 가지고 있음.

  ⇒윈도우 환경에서 실행하는 프로그램을 리눅스 혹은 유닉스에서 실행할 수 있다면 운영체제에 독립적이라고 할 수 있음.

  <img width="418" alt="screen" src="https://github.com/HuiGyun-kim/TIL/assets/105576581/4049f79b-4fa0-4380-8d8f-35bae091c666">


### 다중 스레딩 지원

- 자바는 멀티스레드를 쉽게 구현할 수 있도록 지원하며, 이는 다중 프로세스 및 다중 코어 시스템에서 성능을 최적화하는 데 도움을 줌.

### 보안

- 자바는 안전성을 강조하며, 악의적인 코드 실행을 방지하기 위해 여러 보안 기능을 제공.

### JVM의 구조

- 개발자가 java코드를 작성후 자바의 프로그램이 실행되면 OS로 부터 이 프로그램이 필요로 하는 메모리를 요청하여 할당받고 이 메모리를 용도에 따라 여러 영역으로 나누어 관리.

  ⇒ JVM의 초기화 단계.

- Java compiler가 자바 소스코드를(.java) 를 읽어들여 class 파일로 만들고 Class Loader를 통해 class 파일들을 JVM 내부(RunTime Data Area)로 로딩.
- RunTime Data Area에서 변수들을 저장. 이후 각 환경에 맞게 가상머신이 동작하며 프로그램이 실행.

  ⇒RunTime Data Area(크게 Method영역, Stack영역, Heap영역)

    - JVM이 실행 중에 데이터를 저장하는 공간.
    - Static(Method) 영역 : 클래스의 메타데이터, 정적 변수, static변수, 변수정보, 메소드 정보, 상수 풀 등을 저장. 클래스가 로딩될 때 생성되고 JVM이 종료될때까지 유지.
    - Heap 영역 : 인스턴스를 생성할 때 생성되는 메모리 형식으로, "new"를 사용하여 객체를 만들 때 저장되고 멤버변수, 참조자료형(class, interface,Array)도 같이 저장.
        - 동적으로 생성된 객체와 배열을 저장하며, 가비지 컬렉션을 통해 관리.
        - heap 영역에 저장되는 변수는 명시적으로 해제 해주거나, 가비지컬렉션이 정리하기 전까지는 남아있음.
    - Stack 영역 : 각 스레드마다 스택 프레임을 가지고 있으며, 메소드 호출과 관련된 로컬 변수와 실행 정보를 저장.
        - 변수는 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제됨.

# 주석과 실행문

## 주석 처리

### //:행 주석

⇒ 라인수가 한 줄일 경우 행 주석을 사용.

### /* ~ */ : 범위 주석

⇒ /*와 */ 사이에 있는 모든 범위를 주석으로 처리. 라인 수가 주로 두 줄 이상일 때는 범위 주석을 사용.

```jsx
//한줄짜리 주석
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
/* 
 *  한 줄 이상의 주석
 */
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

```

## 실행문

- 변수 선언, 값 저장, 메소드 호출에 해당하는 코드.
- 컴파일러는 세미콜론을 보고 실행문의 끝을 결정.

### 일반적인 실행문의 종류

- 할당문 : 변수에 값을 할당하는 문장.
- 조건문 : 조건에 따라 프로그램의 흐름을 제어하는 문장으로, `if`, `else if`, `else` 등이 포함.
- 반복문 : 조건을 만족하는 동안 코드 블록을 반복 실행하는 문장으로, `for`, `while`, `do-while` 등이 있음.
- 메소드 호출문 : 메소드를 호출하는 문장으로, 다른 메소드를 실행할 때 사용.

```jsx
int x = 10; // 변수 x에 10을 할당하는   //할당문
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
if (조건) {                            //조건문
    // 조건이 참일 때 실행되는 코드
} else {
    // 조건이 거짓일 때 실행되는 코드
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
for (int i = 0; i < 5; i++) {          //반복문
    // 반복 실행될 코드
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
int result = add(5, 3); //             //add 메소드 호출문
```

# 자바 코드 살펴보기

```java
/* 클래스 블록 */
public class 클래스명 {

    /* 메서드 블록 */
    **[public|private|protected]** [static] (리턴자료형|void) 메서드명1(입력자료형 매개변수, ...) {
        명령문(statement);
        ...
    }

    /* 메서드 블록 */
    **[public|private|protected]** [static] (리턴자료형|void) 메서드명2(입력자료형 매개변수, ...) {
        명령문(statement);
        ...
    }

    ...
}
```

### 클래스 블록

- 클래스 이름 뒤 중괄호 `{}`로 둘러싸인 코드 영역.
- 클래스명은 마음대로 지을 수 있지만, 영문으로 지어야하고 첫 번째 철자는 대문자를 사용.
- 클래스명은 소스파일의 이름과 동일하게 사용해야 함.
- 클래스 블록은 여러 메서드 블록을 품고 있는 형태.

![classblock](https://github.com/HuiGyun-kim/TIL/assets/105576581/cb207b1a-89d1-4241-a70e-73955c3c4a44)

### 메서드 블록

- `[public|private|protected]` 는 **접근제어자**라는 것으로, 이 중에서 하나가 오거나, 아무것도 오지 않아도 된다는 의미.
- 그 다음으로 오는 `[static]` 영역은 **static** 키워드가 있을 수도, 없을 수도 있다는 의미. 해당 키워드가 붙으면 **static 메서드.**
    - static(정적)메서드가 되면, 해당 클래스에 대한 인스턴스 선언 없이도 `클래스명.메서드명` 형태로 사용이 가능하고, 주로 Util 클래스의 메서드에서 많이 사용.
- `리턴자료형` 부터는 필수로 존재해야 하는 부분.
- 메소드가 실행된 후 리턴되는 값의 자료형을 말하고, 만약 리턴 자료형이 없다면 void를 사용하여 리턴값이 없다는 표기가 필요.
- 리턴자료형 다음으로 `메서드명`이 오게 되는데, 메서드명도 클래스명처럼 자유롭게 지을 수 있고, 해당 메서드가 하는 **기능**을 이름으로 짓게 됨.
- 메서드명의 뒤에는 괄호안에 입력 자료형과, 매개변수가 오게됨.

아래 코드를 한줄씩 분석해보겠습니다.

```java
//아래 코드를 한줄씩 분석해보겠습니다. 

public class HelloWorld {
    public static void main(String[] args) { 
        System.out.println("Hello World!");
    }
}
/* 
* 메서드명 - main
* 리턴형 - void (메서드 수행 후 리턴되는 값이 없다는 의미)
* static 메서드 - 클래스 메서드 라고도 불리며, 객체를 만들지 않아도 클래스명.메서드명 형태로 호출이 가능.
* 메서드의 매개변수 - String[] args 자료형은 String 배열이고, args라는 변수명을 갖음.
*/
```

위의 내용을 정리해보면 자바 코드의 구조는 다음과 같음.

![methodblock](https://github.com/HuiGyun-kim/TIL/assets/105576581/3e75b0c7-584d-4856-92b0-937e3303c739)

## 클래스 안에는 어떤 내용이 들어갈까

![classtype](https://github.com/HuiGyun-kim/TIL/assets/105576581/88d3c9e4-c73b-4c23-b55a-8cfd8ff10c5b)

## 헷갈릴 수 있는 용어 정리.

### 가비지 컬렉션과 가비지 컬렉터

1. **가비지 컬렉션(관리주체)**
- 자동 메모리 관리의 과정을 의미.
- 프로그램이 동적으로 할당한 메모리 중에서 더 이상 사용되지 않는 영역(즉, '가비지' 또는 '쓰레기')을 찾아내고, 이를 해제하는 과정을 말함.
- 가비지 컬렉션은 프로그램의 안정성을 높이고 메모리 누수를 방지하는 데 도움을 줌.
    - 프로그래밍에서 누수현상은 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상을 말하는데, 자바에서 메모리누수는 더 이상 사용하지 않는 객체가 가비지컬렉션(GC)에 의해 회수되지 않고 누적되는 현상을 말함.
        - 메모리 누수를 막기위한 방법
            - 가장 좋은 방법은 참조값을 갖는 변수가 최소한의 유효범위안에 있도록 하는 것.
            - Local변수로 만들 경우 자동으로 GC의 대상이 되는 것을 예로 들 수 있음.
            - 더 이상 필요하지 않는 객체나 자원을 명시적으로 해제하는것으로, 이를 위해 close() 메서드나 finally 블록을 활용할 수 있음.

            ```jsx
            import java.io.*;
            
            public class FileExample {
                public static void main(String[] args) {
                    try {
                        FileInputStream fileInputStream = new FileInputStream("example.txt");
                        
                        // 파일에서 데이터 읽는 작업 수행
                        // ...
            
                        // 파일을 닫음
                        fileInputStream.close();
                    } catch (FileNotFoundException e) {
                        System.err.println("파일을 찾을 수 없습니다.");
                    } catch (IOException e) {
                        System.err.println("파일을 읽는 동안 오류가 발생했습니다.");
                    }
                }
            }
            ```

1. **가비지 컬렉터(실행주체)**
- 가비지 컬렉션 과정을 실제로 수행하는 시스템 또는 프로그램의 일부분을 지칭.
- 즉, 가비지 컬렉터는 더 이상 사용되지 않는 메모리를 자동으로 탐지하고 회수하는 기능을 수행

```
💡 하루 10개 질문
```


| 번호 | 질문 |
| --- | --- |
| 1 | 자바의 장점과 단점을 설명해주세요. |
| 2 | 자바의 구동원리를 설명해주세요. |
| 3 | 자바의 메모리 구조에 대해 설명해주세요. |
| 4 | JVM의 특징은 무엇인가요? |
| 5 | 멤버변수와 지역변수는 heap과 stack 어디에 저장될까요? |
| 6 | Stack 영역에 저장되는 변수는 언제 메모리가 해제되나요? |
| 7 | Heap 영역에 저장되는 변수는 언제 메모리가 해제되나요? |
| 8 | 가비지 컬렉션이란 무엇인가요? |
| 9 | 메모리 누수가 무엇인가요? |
| 10 | 메모리 누수를 막기위한 방법은 무엇인가요? |