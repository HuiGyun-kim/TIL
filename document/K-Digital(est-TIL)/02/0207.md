# 사용자 정의 예외와 예외발생

## 사용자 정의 예외 클래스 선언

자바 표준 API에서 제공하는 예외 클래스만으로는 다양한 종류의 예외를 표현할 수 없기때문에 은행 잔고 부족 예외와 같이 기존에 없는 애플리케이션 서비스와 관련된 예외는 개발자가 직접 정의해서 만들어야하므로 사용자 정의 예외가 필요.

```java
public class XXXException extends Exception { 
	public XXXException() { }
	public XXXException(String message) {  super(message);  }
}

or 

public class XXXException extends RuntimeException {
	public XXXException() { }
	public XXXException(String message) {  super(message);  }
}
```

사용자 정의 예외 클래스는 컴파일러가 체크하는 **일반 예외**로 선언할 수도 있고, 컴파일러가 체크하지 않는 실행 가능.

- 일반 예외로 선언할 경우 Exception을 상속하고, 실행 예외로 선언할 경우에는 RuntimeException을 상속.
- 사용자 정의 예외 클래스의 네이밍도 `Exception`으로 끝나는 것이 좋음.
- 사용자 정의 예외 클래스도 필드, 생성자, 메소드 선언들을 포함할 수 있지만 대부분 생성자 선언만을 포함.

생성자는 두 개를 선언하는 것이 일반적인데, 하나는 매개변수가 없는 기본 생성자 이고,

```java
public XXXException() { }
```

다른 하나는 예외 발생 원인 메시지를 전달하기 위해 String 타입의 매개 변수를 갖는 생성자.

```java
public XXXException(String message) {  super(message);  }
```

String 타입의 매개 변수를 갖는 생성자는 상위 클래스의 생성자를 호출하여 예외 메시지를 넘김. 예외 메시지의 용도는 catch { } 블록의 예외 처리 코드에서 이용하기 위함

다음은 잔고 부족 예외를 사용자 정의 예외 클래스로 선언한 것.

```java
public class BalanceInsufficientException extends Exception { 
	public BalanceInsufficientException() {  
	}

	public BalanceInsufficientException(String message) {
		super(message);
	}
}
```

`BalanceInsufficientException` 은 `Exception`을 상속하기 때문에 컴파일러에 의해 체크되는 예외가 되기때문에 **try-catch 블록으로 예외 처리가 필요.**

## 예외 발생시키기

```java
throw new XXXException();

혹은

throw new XXXException("메시지");
```

하나는 기본 생성자, 또 하나는 예외 메시지를 갖는 생성자.

- throw를 이용해서 해당 예외를 던져주는(발생시키는) 역할.
- 예외 발생 코드를 가지고 있는 메소드는 내부에서 try-catch 블록으로 예외를 처리할 수 있지만, 대부분은 자신을 호출한 곳에서 예외를 처리하도록 throws 키워드로 예외를 떠넘김.

```java
public void method() throws XXXException {
	throw new XXXException("예외 메시지");
}
```

그렇기 때문에 throws 키워드를 포함하고 있는 메소드는 호출한 곳에서 다음과 같이 예외 처리가 필요.

```java
try {
	method();
} catch (XXXException e) {
	// 예외 처리 코드
}
```

다음 예제는 은행 계좌(Account) 클래스를 작성한 것으로, 출금 메소드에서 잔고 필드와 출금액을 비교해서 잔고가 부족하면 `BalanceInsufficientException`을 발생시키도록 함.

```java
public class Account {
	private long balance;

	public Account() {
	}

	public long getBalance() {
		return balance;
	}
	
	public void deposit(int money) {
		balance += money;
	}
	
	public void withdraw(int money) throws BalanceInsufficientException { // 사용자 정의 예외 떠넘기기
		if (balance < money) {
			throw new BalanceInsufficientException("잔고가 부족합니다. " + (balance - money) + " 부족함");  // 사용자 정의 예외 발생 
		}

		balance -= money;
	}
}
```

위에서 사용자 정의 예외를 발생시킨 방법은 `throw new BalanceInsufficientException();` 으로 발생시켰고, 해당 예외를 떠넘긴 방법은 메소드 선언 옆에 `throws BalanceInsufficientException` 예외로 던져, 해당 메소드를 사용하는 곳에서 try-catch 문을 이용해 예외처리.

다음 AccountExample 클래스는 Account 클래스를 이용해서 예금과 출금을 실행. 출금할 때 withdraw() 메소드를 사용하므로 예외 처리가 꼭 필요.
예외 처리 코드에서 BalanceInsufficientException 객체의 getMessage() 메소드로 예외에 대한 정보를 출력중.

```java
public class AccountExample {
	public static void main(String[] args) {
		Account account = new Account();

		// 예금하기
		account.deposit(30000);
		System.out.println("예금액: " + account.getBalance());

		// 출금하기
		try {
			account.withdraw(100000);
		} catch (BalanceInsufficientException e) {
			// 예외 발생 경로를 추적
			System.out.println(e.getMessage());
			e.printStackTrace();
		}
	}
}
```

printStackTrace는 메소드 이름에서도 알 수 있듯이 예외 발생 코드를 추적해서 모두 콘솔에 출력하는 역할. 하지만 실무에서는 예외 발생 코드를 모두 출력하는 printStackTrace를 사용하지 않고, 필요한 log만 찍을 수 있도록 하는 로깅을 사용.

### throw와 throws의 차이

이 둘은 예외 처리와 관련된 키워드로 다음의 차이점을 가짐.

- throw: 메소드 내에서 예외를 발생시키는 데 사용. (`throw new BalanceInsufficientException()`)
- throws: 메소드 선언부에서 사용되며, 해당 메소드가 처리하지 않은 예외를 호출자에게 전달한다는 의미를 내포하고 있음 (`public void withdraw(int money) throws BalanceInsufficientException`)

# try-catch와 throws의 사용하는 시기

### **try-catch를 사용하는 경우:**

- **예외를 즉시 처리**해야 할 때: 예외가 발생한 지점에서 바로 처리할 수 있고, 이후 코드의 실행이 가능하다면 `try-catch`를 사용. 이는 예외를 로깅하고, 사용자에게 친절한 메시지를 제공하며, 대체 작업을 수행하거나 리소스를 정리하는 등의 작업을 수행이 가능.
- **복구가 가능한 예외**일 때: 예외 상황을 복구하고 프로그램을 계속 실행할 수 있는 경우에 사용. 예를 들어, 파일을 읽는 동안 문제가 발생하면 다른 파일로 대체하거나 사용자에게 재시도를 요청 가능.
- **API 설계**: 라이브러리나 프레임워크를 작성할 때 사용자가 예외를 처리하도록 강제하기 보다는, 내부적으로 예외를 처리하여 API 사용자에게 편리한 인터페이스를 제공하고자 할 때 사용.

### **throws를 사용하는 경우:**

- **예외 처리를 호출자에게 위임**할 때: 메서드가 예외를 처리하는 것이 적절하지 않거나, 예외를 처리할 정보가 부족한 경우에는 호출자에게 예외 처리를 위임.
- **체크된 예외(Checked Exception)를 던질 때**: 자바에서 체크된 예외는 **호출자가 이를 처리하도록 강제**함. 이러한 예외는 `throws`를 사용하여 선언해야 하며, 이를 통해 예외가 발생할 수 있는 API를 사용하는 개발자가 이를 인지하고 대응할 수 있도록 함.

### **일반적으로 쓰이는 상황:**

- 체크된 예외(Checked Exceptions)는 호출자가 예외를 처리하도록 **의도된 경우** `throws`를 사용. 이는 주로 예외를 복구할 수 있거나, 호출자가 예외에 대한 대응을 달리 할 수 있는 상황에 적합.
- 언체크된 예외(Unchecked Exceptions, RuntimeExceptions)는 프로그램의 로직 오류를 나타낼 때 주로 발생하며, 이 경우 종종 `try-catch`를 사용하여 적극적으로 잡아내기보다는 프로그램의 오류를 수정하는 방식으로 처리.
- 두 방법을 혼합하여 사용하는 것이 일반적이고, **중요한 것은** 예외 처리 전략이 일관성 있고, 명확한 규칙에 따라 구현되어야 한다는 점.
- 예외 처리는 프로그램의 안정성, 유지보수성, 그리고 사용자 경험에 큰 영향을 미치므로, 어떻게 예외를 처리할지는 신중하게 고려되어야함.

# 예외 트랜잭션 처리 방법

트랜잭션이란 여러개의 작업을 논리적으로 묶어 하나의 작업 단위로 처리하는것으로, 이러한 묶음은 모두 성공하거나 모두 실패해야함.

트랜잭션은 데이터베이스의 일관성을 유지하고 데이터 조작의 안전성을 보장하는데. 예를 들어 은행에서의 ‘송금’ 트랜잭션에는 다음과 같은 작업들이 있음.

- 송금 ‘처리중’ 상태로 변경.
- 송금인 계좌에 돈이 빠져나감.
- 수금인 계좌에 돈이 채워짐.
- 송금 ‘완료’ 상태로 변경.

송금 프로세스 중 하나라도 실패하면 모두 취소하고 ‘송금’ 전의 상태로 **롤백**이 필요**.**

```java
돈_송금() {
	송금_상태변경(처리중);
	송금인_계좌_출금();
	수금인_계좌_입금();
	송금_상태변경(완료);
}

송금_상태변경(status) {
	...
}

송금인_계좌_출금() {
	...
}

수금인_계좌_입금() {
	...
}
```

이때 예외처리로 방법으로는 송금 상태변경, 송금인 계좌출금, 수금인 계좌입금 메소드에서는 각각 예외를 던지고 돈 송금 메소드에서 던져진 예외를 처리한 뒤 모두 취소하는 것이 완벽한 트랜잭션 처리 방법.

```java
돈_송금() {
	try {
		송금_상태변경(처리중);
		송금인_계좌_출금();
		수금인_계좌_입금();
		송금_상태변경(완료);
	} catch (예외) {
		모두취소();
	}
}

송금_상태변경(status) throws 예외 {
	...
}

송금인_계좌_출금() throws 예외 {
	...
}

수금인_계좌_입금() throws 예외 {
	...
}
```

이와 같이 코드를 작성하면 송금 상태변경, 송금인 계좌출금, 수금인 계좌입금 작업 중 하나라도 실패할 경우 예외가 발생하여 계좌간 송금 작업이 **모두 취소 가능**.

### **트랜잭션의 ACID 속성**

트랜잭션은 ACID 속성을 만족해야 함.

1. **원자성(Atomicity)** : 트랜잭션 내의 모든 연산은 전부 실행되거나, 전부 실행되지 않아야 하고, 중간 단계에서 실패한다면, 이전 상태로 롤백되어야 함.
2. **일관성(Consistency)** : 트랜잭션이 성공적으로 완료되면, 데이터베이스는 하나의 일관된 상태에서 다른 일관된 상태로 변화해야 함.
3. **독립성(Isolation)** : 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 서로의 연산에 영향을 받지 않고 독립적으로 실행되어야 함.
4. **지속성(Durability)** : 트랜잭션이 성공적으로 완료된 후에는, 그 결과가 영구적으로 데이터베이스에 반영되어야 함.

### **트랜잭션의 용도**

- **금융 시스템** : 은행 거래와 같이 정확성이 중요한 시스템에서 트랜잭션을 사용.
- **E-커머스** : 주문 처리 시스템에서 상품 주문, 결제 처리, 재고 관리 등 여러 데이터베이스 작업을 하나의 트랜잭션으로 관리.
- **데이터베이스 복구** : 시스템 오류 또는 장애 발생 시, 트랜잭션 로그를 사용하여 데이터베이스를 안정적인 상태로 복구.
- **데이터의 일관성 유지 :** 데이터베이스의 무결성을 보장하며, 오류나 중단이 발생해도 데이터의 일관성을 유지.
- **동시성 제어** : 여러 사용자나 애플리케이션이 동시에 데이터베이스에 접근할 때, 데이터의 정합성을 유지하며 충돌을 방지.

### **주의사항**

- 너무 많은 작업을 하나의 트랜잭션으로 처리하면 성능 문제가 발생할 수 있으므로, 트랜잭션의 크기를 적절히 조절해야함.
    - 조절하는법

      **1. 트랜잭션 분할**

        - 작업 분할: 큰 트랜잭션을 여러 개의 작은 트랜잭션으로 나누기.
            - 대량의 데이터를 삽입, 수정, 삭제해야 할 때, 이를 한 번에 처리하는 대신, 데이터를 적절한 크기로 나누어 여러 트랜잭션으로 처리.
        - 비즈니스 로직 분석: 비즈니스 로직을 분석하여 트랜잭션이 필수적인 작업과 그렇지 않은 작업을 구분. 가능한 한 트랜잭션을 필요한 최소한의 작업에만 사용.

      **2. 트랜잭션 격리 수준 조정**

        - 격리 수준 조정: 데이터베이스의 격리 수준을 조정하여 성능과 일관성 사이의 균형을 맞추기. 격리 수준이 높을수록 데이터 일관성은 높아지지만, 성능이 저하될 수 있고, 반대로 격리 수준을 낮추면 동시성은 증가하지만, 데이터의 일관성 문제가 발생.
            - JDBC API를 이용하여 트랜잭션 격리 수준을 설정 가능.
            - `java.sql.Connection` 클래스의 `setTransactionIsolation(int level)` 메소드를 이용.

      **3. 로그 기록 최적화**

        - 로그 기록 줄이기: 트랜잭션 로그의 양을 최소화하기 위해 가능하면 로그 기록이 적은 연산을 선택. 예를 들어, 대량의 데이터를 삽입할 때는 일괄 처리(Batch Insert)를 사용하는 것이 좋음.

      **4. 데이터베이스 최적화**

        - 인덱스 최적화: 데이터 액세스 속도를 높이기 위해 적절한 인덱스를 생성하고 유지 관리. 불필요한 인덱스는 제거하여 인덱스 관리 비용을 줄임.
        - 데이터베이스 설정 조정: 데이터베이스의 설정을 조정하여 성능을 향상. 예를 들어, 캐시 크기를 조정하거나, 쿼리 최적화 파라미터를 조정하는 방법.
- 데드락 : 여러 트랜잭션이 서로의 자원을 기다리며 무한히 대기하는 상황을 방지해야 함. 데드락 탐지 및 회복 기법을 적용이 필요.

```
💡 하루 10개 질문
```


| 번호 | 질문 |
| --- | --- |
| 1 | 사용자 정의 예외 클래스를 만드는 이유는 무엇인가요? |
| 2 | 사용자 정의 예외를 만들 때 RuntimeException과 Exception의 차이는 무엇이고, 어떤 상황에서 어떤 것을 선택해야 하나요? |
| 3 | 체크된 예외와 언체크된 예외의 차이점은 무엇이며, 각각 어떤 경우에 사용하는 것이 적절한가요? |
| 4 | throws와 throw의 차이점에 대해 설명할 수 있나요? |
| 5 | throw new Exception()과 throw new RuntimeException()을 사용할 때의 차이점과 각각의 적절한 사용 상황은 무엇인가요? |
| 6 | 예외 처리에서 try-catch 블록을 사용하는 이유는 무엇이며, 어떤 경우에 주로 사용하나요? |
| 7 | 예외 처리에서 throws를 사용하는 이유와 주로 사용되는 상황은 무엇인가요? |
| 8 | 트랜잭션의 개념과 그 중요성에 대해 설명해주실 수 있나요? |
| 9 | 트랜잭션에서 롤백의 개념과 그 중요성은 무엇인가요? |
| 10 | 트랜잭션 처리에서 롤백이 왜 필요한지 설명할 수 있나요? |

## 배운점/힘들었던점

1. 예외 처리를 통해 프로그램의 안전성을 높이는데 크게 기여할 수 있고, 예외 처리를 구현할때는 신중하게 설계하고 구현해야 한다는 것을 깨달음.
2. 특정 상황에서는 try-catch를 사용하는 것이 좋을지, 아니면 throws를 통해 예외 처리를 호출자에게 위임하는 것이 좋을지 결정하는게 어려움. ⇒ 많은 실전 경험이 필요할 것으로 느낌.