# 메소드 재정의(=메소드 오버라이딩)

상속 관계에 있는 부모 클래스의 메소드를 자식 클래스에서 다시 정의하거나 재구현하는 과정을 의미하고, 메소드 재정의를 통해 자식 클래스는 부모 클래스의 동일한 이름의 메소드를 갖지만 자신에 맞게 동작하도록 변경가능.

### 주의사항

- 재정의하는 메소드는 부모 클래스의 메소드와 동일한 시그니처(이름, 매개변수)를 가져야함.
    - 시그니처가 일치하지 않으면 컴파일 오류가 발생.
- 자식 클래스에서 오버라이딩된 메소드는 부모 클래스의 메소드보다 더 제한적인 접근 수준을 가질 수 없음
- 메소드 재정의 시 `@Override` 어노테이션을 사용하면 컴파일러가 오버라이딩의 정확성을 체크하도록 도와주어 버그를 방지하는데 도움을 줌.
- 부모 클래스에서 `final`로 선언된 메소드는 재정의 불가.
- 자식 클래스에서 재정의한 메소드는 부모 클래스의 메소드보다 더 많은 예외를 던질 수 없고, 부모 클래스의 메소드와 일치하거나 예외를 던지지 않는 방향으로만 변경할 수 있음.

## 메소드 오버로딩

메소드의 이름은 같지만 매개변수의 개수 또는 타입이 다른 여러 버전의 메소드를 정의하는 것.

- 동일한 리턴 타입과 메소드명, 다른 매개변수

```java
void sleep()
void sleep(int hour)
```

- 오버로딩 사용예시

```java
class Calculator {  // add메서드의 오버로딩.
    // 두 정수의 합을 계산하는 메소드
    public int add(int a, int b) {
        return a + b;
    }
    
    // 세 정수의 합을 계산하는 메소드
    public int add(int a, int b, int c) {
        return a + b + c;
    }
    
    // 두 실수의 합을 계산하는 메소드
    public double add(double a, double b) {
        return a + b;
    }
}

public class TestOverloading {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        System.out.println(calc.add(1, 2));       // 출력: 3
        System.out.println(calc.add(1, 2, 3));    // 출력: 6
        System.out.println(calc.add(1.0, 2.0));   // 출력: 3.0
    }
}
```

### 주의사항

1. 매개변수 개수 또는 타입이 달라야 함.
2. 메소드 오버로딩은 반환 타입에 영향을 미치지 않음.
3. 오버로딩된 메소드들은 매개변수의 타입, 개수, 순서 중 적어도 하나가 달라야 함.

# 추상클래스

하나 이상의 추상 메소드(구현 코드 없이 메소드 선언만 있는 메소드)를 포함할 수 있는 클래스로, 메서드가 부분적으로만 구현되어 있으므로, 직접 인스턴스화할 수 없음.

대신, 다른 클래스가 추상 클래스를 상속받아 모든 추상 메소드를 구현함으로써 사용됨.

추상 클래스의 주된 목적은 공통의 기본 기능을 정의하고, 이를 상속받는 서브 클래스에서 이 기능들을 구체화하는 데 있음.

```java
//예시)

abstract class Animal {
    abstract void sound();

    public void breathe() {
        System.out.println("동물이 숨을 쉽니다.");
    }
}

class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("강아지가 멍멍 짖습니다.");
    }
}

public class TestAbstract {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.sound(); // 출력: 강아지가 멍멍 짖습니다.
        myDog.breathe(); // 출력: 동물이 숨을 쉽니다.
    }
}
```

### **주의사항**

1. **인스턴스 생성 불가** : 추상 클래스는 직접 인스턴스화 불가. 반드시 상속을 통해 추상 메소드를 구현한 후 자식 클래스의 인스턴스를 생성해야 함.
2. **추상 메소드 구현** : 추상 클래스를 상속받는 모든 자식 클래스는 부모 추상 클래스의 모든 추상 메소드를 구현해야 함. 만약 자식 클래스에서 모든 추상 메소드를 구현하지 않는다면, 그 자식 클래스도 추상 클래스로 선언되어야 함.
3. **접근 제한자** : 추상 메소드는 `private` 접근 제한자를 가질 수 없음.

   ⇒ 추상 메소드의 목적이 서브 클래스에서의 오버라이딩을 통한 구현에 있기 때문.

4. **생성자 정의 가능** : 추상 클래스는 생성자를 가질 수 있음. 이 생성자는 주로 서브 클래스의 생성자에서 `super()`를 통해 호출.
5. **추상 클래스와 일반 메소드** : 추상 클래스는 추상 메소드뿐만 아니라 일반 메소드(구현된 메소드)도 포함 하여 서브 클래스에 공통적인 구현을 제공할 수 있음.

## 추상메서드

추상 메서드란 **자식 클래스에서 반드시 오버라이드 해야만 사용할 수 있는 메소드**를 말함.

추상메서드를 선언하는 이유는, 서브 클래스에게 특정 메서드를 구현하도록 강제하기 위함.

```java
abstract 리턴타입 메소드명();

//실사용 예시
abstract class Animal {
    abstract void sound(); //자식클래스에서 sound라는 추상메소드를 구현하도록 강제.
}
```

### **주의사항**

1. **추상 클래스 내 선언** : 추상 메서드는 반드시 추상 클래스 내에 선언 되어야하지만 추상 클래스는 추상 메서드 없이도 정의될 수 있음.
2. **구현부의 부재** : 추상 메서드는 구현부를 가질 수 없기때문에, 메서드 선언 끝에 세미콜론(**`;`**)을 사용하여 메서드 본체가 없음을 명시해야함.

## 추상 클래스의 용도

실체 클래스들의 공통적인 특성(필드, 메소드)을 뽑아내어 추상 클래스로 만드는 이유에는 다음 4가지가 있음.

1. **실체 클래스를 작성할 때 시간을 절약 :** 공통적인 필드와 메소드는 추상 클래스인 Phone에 모두 선언해두고, 실체 클래스마다 다른 점만 실체 클래스에 선언하게되면 실체 클래스를 작성하는데 시간을 절약할 수 있음.
2. **공통된 특징의 추상화 :** 추상 클래스는 서로 다른 클래스들 사이에 공통된 특징을 추상화하여 추상 클래스로 공통 특징을 묶어두면, 코드의 재사용성과 유지보수성이 향상.
3. **하위 클래스에게 구현을 강제화 :** 추상 클래스 내에는 하나 이상의 추상 메서드가 포함되며, 이러한 추상 메서드는 하위 클래스에서 반드시 구현되어야 함. 따라서 추상 클래스를 상속받는 하위 클래스들은 특정 동작을 구현하도록 강제화되며, 일관된 인터페이스를 제공.
4. **다형성 구현 :** 추상 클래스를 이용하여 다양한 하위 클래스 객체를 동일한 추상 클래스 타입으로 다룰 수 있어 다형성을 구현하는 데 기여.

# 인터페이스란

자바에서 인터페이스란, 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할을 하는 일종의 추상 클래스를 의미.

### 특징

1. **추상 메서드 정의:** 인터페이스는 추상 메서드를 정의함. 이 추상 메서드들은 인터페이스를 구현하는 클래스에서 반드시 구현되어야 함.
2. **다중 상속 지원:** 클래스는 다중 상속을 지원하지 않는 언어에서도 인터페이스를 이용하여 다중 상속을 구현이 가능. 하나의 클래스가 여러 인터페이스를 구현할 수 있으므로 다양한 동작을 결합이 가능.
3. **코드의 일관성:** 인터페이스를 사용하면 클래스 간에 특정 동작이나 기능을 공유할 수 있으므로 코드의 일관성을 유지하고 유지보수를 쉽게 할 수 있음.
4. **인터페이스 간 상속:** 인터페이스는 다른 인터페이스를 상속할 수 있으며, 상속받은 인터페이스의 추상 메서드도 구현해야 함.

### 주의사항

1. 인터페이스 내의 모든 메서드는 `public`이어야 함. 따라서 인터페이스를 구현하는 클래스에서는 메서드를 `public` 접근 지정자로 구현해야 함.
2. 클래스가 인터페이스를 구현할 때에는 `implements` 키워드를 사용.
3. 인터페이스를 상속받을 때에는 `extends` 키워드를 사용.
4. 인터페이스에서 정의한 메서드를 모두 구현해야 하며, 그렇지 않으면 컴파일 오류가 발생.
5. 하나의 클래스가 여러 인터페이스를 구현이 가능.

그럼 인터페이스가 왜 필요한지 알아볼게요. 다음 요구사항을 클래스로 작성해봅시다.

```java
다음은 어떤 동물원의 사육사가 하는 일이다.

난 동물원(zoo)의 사육사(zookeeper)이다.
육식동물(predator)이 들어오면 난 먹이를 던져준다(feed).
 - 호랑이(tiger)가 오면 고기(meat)를 던져준다.
 - 사자(lion)가 오면 생선(fish)를 던져준다.
```

이와 같은 내용을 코드로 표현하기 위해 Animal, Tiger, Lion, Zookeeper 클래스를 작성.

(원래대로 라면 각각의 클래스를 따로 분리해야하지만, 하나의 코드로 담기위해 한번에 작성)

```java
public class Sample {
	public static void main(String[] args) {
		ZooKeeper zooKeeper = new ZooKeeper();
		
		Tiger tiger = new Tiger();
		zooKeeper.feed(tiger);
		
		Lion lion = new Lion();
		zooKeeper.feed(lion);
	}
}

class Animal {
	String name;

	void setName(String name) {
		this.name = name;
	}
}

class Tiger extends Animal {
}

class Lion extends Animal {
}

class ZooKeeper { //앞서 배운 오버로딩 방식이용.
	void feed(Tiger tiger) {  // 호랑이가 오면 고기를 던져 준다.
		System.out.println("feed meat");
	}

	void feed(Lion lion) {  // 사자가 오면 생선을 던져준다.
		System.out.println("feed fish");
	}
}

//결과
feed meat
feed fish
```

## 인터페이스의 선언과 사용

인터페이스의 선언은 class 키워드 대신에 interface 키워드를 사용.

인터페이스는 다른 클래스에서 구현하고 사용해야 하므로, 모든 구현 클래스에서 접근할 수 있어야 하기 때문에 public사용이 필요.

```java
public interface 인터페이스명 { ... }

//실사용 예시)
interface Predator { 
String getFood();
}  // 육식동물 인터페이스 생성 
```

그리고 Tiger, Lion 클래스는 Predator 인터페이스를 구현하도록 다음과 같이 implements라는 키워드를 사용해 수정.

```java
class Tiger extends Animal implements Predator {
	...
}

class Lion extends Animal implements Predator {
	...
}
```

각 육식동물 클래스는 `Predator` 인터페이스를 구현하고, `getFood()` 메소드를 통해 자신이 먹는 음식을 반환.

```java
class Tiger extends Animal implements Predator {
    @Override
    public String getFood() {
        return "meat";
    }
}

class Lion extends Animal implements Predator {
    @Override
    public String getFood() {
        return "fish";
    }
}
class ZooKeeper {
    void feed(Predator predator) {
        System.out.println("feed " + predator.getFood());
    }
}
```

ZooKeeper 클래스는 `feed` 메소드에서 `Predator` 인터페이스의 `getFood()` 메소드를 호출함으로써, 각 동물이 먹는 음식을 출력.

이 방식으로, 다양한 `Predator` 구현체를 동일한 방식으로 처리가 가능.

- tiger : Tiger 클래스의 객체이자 Predator 인터페이스의 객체.
- lion : Lion 클래스의 객체이자 Predator 인터페이스의 객체.

이제 어떤 ‘육식동물’ 클래스가 추가되더라도 Zookeeper는 feed메소드를 추가할 필요가 없음.

다만, 클래스가 추가된다면 육식동물 Predator 인터페이스는 구현이 필요.

```java
class Crocodile extends Animal implements Predator {
}
```

# 알아두면 괜찮은 내용.

### **추상 클래스 사용 시기**

1. **공통된 코드가 많을 때** : 공통된 코드를 메서드로 구현하여 상속받는 서브 클래스에서 재사용 가능.
2. **기본적인 메서드 구현을 제공하고자 할 때** : 일부 메서드는 기본 구현을 제공하고, 일부는 서브 클래스에서 구현하도록 강제하고 싶을 때 추상 클래스를 사용.
3. **클래스 계층구조를 구성하려 할 때** : 특정 계층구조에서만 사용되어야 하는 공통의 속성이나 메서드를 정의하는 데 유용.

### **인터페이스 사용 시기**

1. **다중 구현이 필요한 경우** : 자바는 다중 상속을 지원하지 않으므로, 클래스가 여러 타입으로 동작해야 할 때 인터페이스를 사용.
2. **API를 정의할 때** : 인터페이스는 메서드의 시그니처만을 정의하기 때문에, 구현을 강제하려는 목적으로 API를 설계할 때 주로 사용.
3. **서로 관련 없는 클래스들에게 공통의 동작을 부여할 때** : 인터페이스는 구현 클래스들 사이의 계층구조가 없는 경우에도 공통의 동작에 대한 정의가 가능.

```
💡 하루 10개 질문
```

| 번호 | 질문 |
| --- | --- |
| 1 | 메소드 오버라이딩과 메소드 오버로딩의 차이점은 무엇이며, 각각의 사용 예시를 들어줄 수 있나? |
| 2 | 메소드 오버라이딩 시, 자식 클래스에서 추가할 수 있는 예외 처리에 대한 규칙을 설명할 수 있나? |
| 3 | 하위 클래스에서 부모 클래스의 메소드를 오버라이드할 때 접근 제한자를 변경할 수 있는 규칙에 대해 설명할 수 있나? |
| 4 | final로 선언된 메소드는 왜 오버라이드할 수 없는지, 그 이유와 함께 설명할 수 있나? |
| 5 | @Override 어노테이션의 역할은 무엇이고, 왜 사용하는지 설명할 수 있나? |
| 6 | 추상 클래스가 인스턴스화될 수 없는 이유는 무엇인가? |
| 7 | 인터페이스와 추상 클래스의 차이점을 설명하고, 각각 어떤 상황에서 사용하는 것이 더 적합한지 예를 들어 설명할 수 있나? |
| 8 | Java에서 인터페이스를 사용하는 주된 이유와 장점에 대해 설명할 수 있나? |
| 9 | 다중 상속의 문제점은 무엇이며, 인터페이스를 통해 이 문제를 어떻게 해결할 수 있는지 설명할 수 있나? |
| 10 | 인터페이스의 default 메소드가 도입된 배경과 이로 인해 얻을 수 있는 이점은 무엇인가? |

## 배운점/힘들었던점

1. 인터페이스와 추상 클래스를 통해 프로그램의 유연성과 확장성을 높이는 방법을 다시 한번 깊이 이해하는데 도움을 받음.
2. 객체 지향 프로그래밍의 핵심 개념을 잘 활용하면, 유지보수가 용이하고 확장성 있는 코드를 작성할 수 있다는 것을 느낌.